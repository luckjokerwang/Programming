# 做题总结（2025-11-26）

本次总结覆盖以下题目与代码文件：
- `Luogu_P_1536_村村通.cpp`
- `Luogu_P_1030_NOIP_2001_普及组_求先序排列.cpp`
- `Luogu_P_1087_NOIP_2004_普及组_FBI_树.cpp`
- `Luogu_P_1185_绘制二叉树.cpp`
- `Luogu_P_1305_新二叉树.cpp`
- `Luogu_P_1364_医院设置.cpp`
- `Luogu_P_2234_HNOI_2002_营业额统计.cpp`
- `Luogu_P_3370_模板_字符串哈希.cpp`
- `Luogu_P_3884_JLOI_2009_二叉树问题.cpp`

---

## P1536 村村通（并查集）
- 输入模式：题目以单独的 `0` 行结束，正确写法：`while (cin >> n && n != 0) { cin >> m; ... }`。
- 合并操作必须在“根节点”层面进行：
  - 错误：`fa[u] = v;`
  - 正确：`int fu = find(u), fv = find(v); if (fu != fv) fa[fu] = fv;`
- 统计连通分量：遍历 `i=1..n`，对 `find(i)` 的代表根，用 `vis[root]` 去重计数，答案为 `cnt - 1`（最少需要建设的道路数）。
- 常见坑：
  - 直接使用 `while (cin >> n >> m)` 会在读到末尾单独 `0` 时读错格式。
  - 合并时不对齐根导致并查集结构混乱、计数错误。

## P1030 求先序排列（中序+后序 → 先序）
- 思路：后序的最后一个字符是当前子树根 `root`；在中序中找到 `root` 的位置，划分左、右子树长度，然后递归。
- 递归顺序：先输出根，再递归左，再递归右（此题实现打印在递归后，以适应输出位置）。当前代码中先打印 `s2[r2]`，之后按中序位置分割递归，逻辑正确。
- 关键实现：
  - `int idx = s1.find(s2[r2]);`
  - 左子树区间：`[l1, idx-1]` 与 `[l2, l2+dist-1]`
  - 右子树区间：`[idx+1, r1]` 与 `[l2+dist, r2-1]`
- 注意：字符串查找与区间边界要一致。

## P1087 FBI 树（区间判定 + 后序输出）
- 判定函数 `check(l, size)`：
  - 若区间全为 `0` → `B`；全为 `1` → `I`；混合 → `F`。
- 递归输出采用“左右子树后序 + 当前段类型”的顺序，最终拼接为题目要求的结构字符串。
- 关键点：区间二分递归，`size` 必须是 2 的幂（或使用 `s.size()` 与构造保证）。

## P1185 绘制二叉树
- 当前仅为 IO 模板，无核心逻辑。若后续实现，需根据题意构造二维字符画并逐行输出。

## P1305 新二叉树（先序遍历）
- 结构体 `tree[char]` 存左右孩子，输入时用字符作为索引构造。
- 递归 `dfs(x)`：若 `x=='*'` 返回；否则输出当前字符，再递归左右孩子。
- 注意：输入时将字符节点的左右孩子存入以字符为下标的数组条目。

## P1364 医院设置（树上最短路和）
- 思路：将每个点作为医院，计算到所有点的加权距离之和，取最小值。
- 当前实现：从每个起点做三向 DFS（父、左、右）并累加 `val*d`。
- 注意：
  - 使用 `vis[]` 防止重复与回返；每次起点需重置。
  - 时间复杂度较高，若数据大需优化（如树 DP：换根 DP）。

## P2234 营业额统计（动态维护集合）
- 数据结构：`set<int>`，每次插入当天营业额，求与已有元素的最小差值。
- 查找：`lower_bound(x)` 获取不小于 `x` 的最小元素，再检查前驱作为候选，取差值最小者。
- 初值：第一天差值为当天营业额本身，随后累加最小差值。

## P3370 模板 字符串哈希（拉链法去重）
- 哈希：`hash = (hash * base + s[i]) % mod`。
- 去重：在桶 `linker[hash]` 中线性查重；若无则 `push_back` 并 `ans++`。
- 注意：当前代码缩进存在陷阱：
  - 建议使用大括号包裹 `for` 中的 `if` 与后续 `push_back/ans++`，避免误读。
- 生产环境建议使用 `unordered_set<string>` 或双哈希以降低碰撞风险。

## P3884 二叉树问题
- 任务包括：
  - 树高：`dfs(1)` 返回左右子树最大深度 + 1。
  - 最大层宽度：层序遍历统计每层队列大小的最大值。
  - 距离查询：支持从任意 `u` 到 `v` 的最短步数（允许向上至父节点），使用 DFS/BFS，带 `vis[]`。
- 注意：父边的代价在当前代码里是 `+2`，需与题意核对（有些题父边可能与子边同价）。

---

## 常见通用坑与建议
- IO 终止条件要与题目匹配（如单独 `0` 行 vs. EOF）。
- 并查集：路径压缩 + 按根合并；统计连通分量用代表根去重。
- 递归边界与区间下标要统一，避免 off-by-one。
- 数据结构选择：查重与哈希需考虑碰撞与复杂度。
- 调试：优先构造小样例与边界样例（空、全同、全异、链状、星状）。

---

以上总结基于当前仓库中的实现与修复记录，后续若新增题目或优化版本，可在此文件继续补充。
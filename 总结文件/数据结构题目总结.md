# 算法题总结

## 1. P1540 NOIP 2010 提高组 机器翻译
- 场景: 模拟翻译系统的缓存 (容量 m), 输入序列长度 n.
- 逻辑: 维护一个队列表示当前缓存; 访问单词 x:
  - 若未出现(vis[x]==false) → 计一次“缺失”并入队; 若队列长度超 m → 弹出队首并清除其标记.
  - 若已存在则忽略.
- 本质: FIFO 缓存置换统计缺页次数.
- 数据结构: queue + bool 数组(标记是否在缓存).
- 时间复杂度: O(n) (每个单词至多入队出队一次).
- 空间复杂度: O(m + V) (V 为单词编号范围).
- 可优化: 若单词编号范围大且稀疏，可用 unordered_set + deque 取代数组标记; 若需 LRU 需改成 list + hash.

## 2. P4387 深基 验证栈序列
- 任务: 判断给定入栈序列 v 能否产生给定出栈序列 p.
- 逻辑: 顺序遍历 v, 每元素入栈后尽可能弹出与 p 当前指针匹配的栈顶; 最终若栈空则合法.
- 原理: 栈的确定性模拟.
- 时间复杂度: O(n).
- 空间复杂度: O(n) (栈 + 序列).
- 可优化:
  - 发现中途无法匹配时可提前终止 (如栈顶与 p[idx] 不等且后续入栈元素都已用完).
  - 若值域连续且为 1..n 且是某种排列关系，可结合单调性快速判定(本题通用做法已足够).

## 3. P2058 NOIP 2016 普及组 海港
- 场景: 按时间顺序到港乘客(携带国家编号), 统计最近 86400 秒窗口内不同国家数量.
- 逻辑:
  - 读入时刻 t 与人数 k, 逐个乘客国家 x 入队 (记录(t,x)), 频次数组 cnt[x]++，若之前为 0 则不同国家计数 +1.
  - 之后弹出队首直到 t - 队首时间 < 86400, 同时维护频次与唯一计数.
- 数据结构: queue<pair<时间, 国家>> + 频次数组.
- 时间复杂度: O(TotalPassengers) (每个乘客仅入队/出队一次).
- 空间复杂度: O(W + C) (W 为窗口内乘客数, C 为国家编号范围).
- 可优化:
  - 若国家编号范围极大: 用 unordered_map 代替数组.
  - 若需更快删除: 可考虑分桶时间但本题已有 O(1) 摊还.
  - 若输入规模很大注意使用 faster I/O.

## 通用注意
- 使用 fast I/O (已采用 ios::sync_with_stdio(false), cin.tie(0)).
- 均为线性复杂度, 已较优.
- 若扩展为并发或大范围 ID, 需改为哈希结构.

## 小型复杂度对比
| 题目 | 时间复杂度 | 空间复杂度 | 主要结构 |
|------|------------|------------|----------|
| P1540 | O(n) | O(m + V) | queue + 标记数组 |
| P4387 | O(n) | O(n) | stack |
| P2058 | O(P) | O(W + C) | queue + 频次数组 |

## 可统一封装建议
- 频次维护模式可封装为 SlidingWindowDistinct 类(适用于时间窗口去重).
- 栈验证可扩展为通用“生成与验证”框架: push/pop回调.

## 可能的进一步增强
- 加入断言与输入合法性检查.
- 封装为函数便于单元测试.
- 统计平均窗口大小或命中率(扩展题目分析).


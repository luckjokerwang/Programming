# 做题总结 2025-11-27

## 今日完成题目

### 1. P2814 家谱 ⭐⭐⭐
**难度**：普及/提高-  
**标签**：并查集、字符串、map

**题目要点**：
- 给定父子关系，查询某人的最早祖先
- 输入格式：`#name`（父亲）、`+name`（儿子）、`?name`（查询）

**解题思路**：
1. **方案一（超时）**：使用 `set<string>` + `distance` / `next`
   - 问题：`distance(st.begin(), it)` 和 `next(st.begin(), idx)` 都是 O(n)
   - 总复杂度：O(m × n)，数据规模大时 TLE
   
2. **方案二（AC）**：使用 `map<string, string>` 直接存储父子关系
   - 并查集的 `find` 函数返回 `string` 类型
   - 路径压缩：`mp[son] = find(mp[son])`
   - 时间复杂度：O(m × log n)

**关键代码**：
```cpp
map<string, string> mp;  // mp[son] = father

string find(string son){
    if(!mp.count(son)) return son;
    if(mp[son] == son) return son;
    return mp[son] = find(mp[son]);  // 路径压缩
}
```

**踩坑记录**：
- ❌ `set` 的迭代器是双向迭代器，不能直接相减
- ❌ `distance` 和 `next` 虽然能用但时间复杂度是 O(n)
- ✅ 用 `map` 直接存储关系最简洁高效

---

### 2. P1955 [NOI2015] 程序自动分析 ⭐⭐⭐
**难度**：普及+/提高  
**标签**：并查集、离散化

**题目要点**：
- 判断一系列等式和不等式约束能否同时满足
- 变量范围：1 ≤ i, j ≤ 10⁹（需要离散化）

**解题思路**：
1. **离散化**：将所有出现的变量值排序去重，建立索引映射
2. **分两步处理**：
   - 第一步：处理所有等式约束（`e=1`），用并查集合并
   - 第二步：检查不等式约束（`e=0`），判断是否在同一集合

**关键代码**：
```cpp
// 离散化
sort(nums.begin(), nums.end());
nums.erase(unique(nums.begin(), nums.end()), nums.end());

int get_id(int x){
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
}

// 先处理等式
sort(q, q + n, [](node a, node b){ return a.e > b.e; });
```

**踩坑记录**：
- ❌ 未做离散化，直接用 i, j 当数组下标（范围太大）
- ❌ 边读边处理，导致等式未完全合并就检查不等式
- ✅ 必须先处理所有等式，再检查不等式

---

### 3. P1102 A-B 数对 ⭐⭐
**难度**：普及-  
**标签**：map、哈希

**题目要点**：
- 找出所有满足 `A - B = C` 的数对个数
- 注意：不同位置的相同数字算不同数对

**解题思路**：
- 用 `map<int, int>` 统计每个数出现的次数
- 对于每个数 `a`，查找 `b = a - c` 的个数
- 数对个数 = `cnt[a] × cnt[a - c]`

**关键代码**：
```cpp
for(auto [a, cnt] : mp){
    ans += cnt * mp[a - c];  // 别忘了乘以 cnt
}
```

**踩坑记录**：
- ❌ 忘记乘以 `cnt[a]`，只计算了 `mp[a - c]`
- ✅ 每个 a 出现多次，需要乘以对应的计数

---

### 4. P1525 [NOIP2010 提高组] 关押罪犯 ⭐⭐⭐
**难度**：普及+/提高  
**标签**：并查集、种类并查集、贪心

**题目要点**：
- 将罪犯分到两个监狱，使最大怨气值最小
- 有仇恨的罪犯不能在同一监狱

**解题思路**：
1. **贪心**：按怨气值从大到小排序
2. **种类并查集**：用 `enemy[i]` 记录 i 的敌人
3. **敌人的敌人是朋友**：将 `enemy[a]` 和 `b` 合并

**关键代码**：
```cpp
sort(v.begin(), v.end(), [](node a, node b){ return a.c > b.c; });

if(find(a) == find(b)){  // 已经在同一监狱
    cout << c << endl;
    return 0;
}
// 敌人的敌人是朋友
if(enemy[a]) join(enemy[a], b);
else enemy[a] = b;
```

---

## 今日知识点总结

### 1. `lower_bound` 的三种用法

| 容器类型 | 用法 | 时间复杂度 |
|---------|------|-----------|
| `vector<int> v` | `lower_bound(v.begin(), v.end(), x)` | O(log n) |
| `int a[N]` | `lower_bound(a, a + n, x)` | O(log n) |
| `set<int> st` | `st.lower_bound(x)` (成员函数) | O(log n) |

**注意**：
- `vector` 和数组：返回迭代器/指针，可以相减
- `set`：迭代器是**双向迭代器**，不能直接相减，需要用 `distance`

### 2. `set` vs `map` 的选择

| 需求 | 推荐容器 | 原因 |
|-----|---------|------|
| 只需判断存在 | `set` / `unordered_set` | 简单高效 |
| 需要索引映射 | `map` | 双向查找 |
| 需要计数 | `map<T, int>` | 统计频次 |
| 需要快速访问第 i 个 | `vector` + 排序 | 随机访问 O(1) |

### 3. 并查集的两种实现

**传统并查集（存储索引）**：
```cpp
int fa[MAXN];
int find(int x){
    if(fa[x] == x) return x;
    return fa[x] = find(fa[x]);
}
```

**字符串并查集（map 实现）**：
```cpp
map<string, string> fa;
string find(string x){
    if(!fa.count(x)) return x;
    if(fa[x] == x) return x;
    return fa[x] = find(fa[x]);
}
```

### 4. 容器内部结构与成员函数

**有 `lower_bound` 成员函数的容器**（都是树结构）：
- `set` / `multiset` → 红黑树
- `map` / `multimap` → 红黑树

**没有 `lower_bound` 成员函数的容器**：
- `vector` / `deque` → 数组/分段数组
- `unordered_set` / `unordered_map` → 哈希表
- `list` → 链表

### 5. 迭代器操作

**随机访问迭代器**（`vector`, `deque`, 数组）：
- 支持：`it + n`, `it - n`, `it1 - it2`
- 获取索引：`it - v.begin()`

**双向迭代器**（`set`, `map`, `list`）：
- 支持：`++it`, `--it`
- 不支持：`it + n`, `it - it2`
- 获取索引：`distance(st.begin(), it)`
- 获取元素：`*next(st.begin(), idx)`

---

## 易错点提醒

1. ⚠️ **`set` 迭代器不能直接相减**，必须用 `distance`
2. ⚠️ **离散化时别忘了排序 + 去重**：`sort` → `unique` → `erase`
3. ⚠️ **并查集判断要用 `find(x)`**，不能直接用 `fa[x]`
4. ⚠️ **计数问题别忘了乘以频次**：`cnt[a] × cnt[b]`
5. ⚠️ **处理约束类问题**：先处理等式，再检查不等式
6. ⚠️ **性能优化**：优先用 `map` 存映射，避免 O(n) 的 `distance`/`next`

---

## 今日刷题统计

- ✅ 完成题目：9 题
- ⭐ 重点题目：P2814（map并查集）、P1955（离散化）、P1525（种类并查集）
- 🎯 知识点：并查集、map/set、离散化、lower_bound
- ⏱️ 总用时：约 4 小时

---

## 明日计划

- [ ] 复习图论基础
